open! Core
include Cint0

let dtype ~bits =
  Dtype.Wrap.create ~equal ~sexp_of_t
    ~max_layout_of:(fun v -> Bits_fixed (bitwidth v))
    ~cint_of:(fun v -> v)
    ~of_cint:(fun v -> Some v)
    ~layout:(Bits_fixed bits) ~expr_tag:Expr.CInt.tag

let dtype_8 = dtype ~bits:8
let dtype_16 = dtype ~bits:16
let dtype_32 = dtype ~bits:32
let dtype_64 = dtype ~bits:64

(* basically all of the rest of this should be able to be autogenerated *)

let ones_mask ~lower_inc ~upper_inc =
  assert (Int.(lower_inc <= upper_inc));
  let num_bits = Int.(upper_inc - lower_inc + 1) in
  (pow (of_int 2) (of_int num_bits) - of_int 1)
  * pow (of_int 2) (of_int lower_inc)

module E = struct
  type t = Expr.CInt.t

  let var v = Expr.CInt.var v
  let const c = Expr.CInt.const c
  let cint i = Expr.CInt.cint i

  (* constants *)
  let zero = cint 0
  let one = cint 1
  let two = cint 2
  let three = cint 3
  let four = cint 4
  let five = cint 5

  (* ops *)
  let add a b = Expr.CInt.add a b
  let sub a b = Expr.CInt.sub a b
  let sub_wrap a b ~bits = Expr.CInt.sub_wrap a b ~bits
  let mul a b = Expr.CInt.mul a b
  let div a b = Expr.CInt.div a b
  let mod_ a b = Expr.CInt.mod_ a b
  let lshift a ~amt = Expr.CInt.lshift a ~amt
  let rshift a ~amt = Expr.CInt.rshift a ~amt
  let bit_and a b = Expr.CInt.bit_and a b
  let bit_or a b = Expr.CInt.bit_or a b
  let bit_xor a b = Expr.CInt.bit_xor a b
  let eq a b = Expr.CInt.eq a b
  let ne a b = Expr.CInt.ne a b
  let clip e ~bits = Expr.CInt.clip e ~bits
  let add_wrap a b ~bits = add a b |> clip ~bits
  let mul_wrap a b ~bits = mul a b |> clip ~bits

  let bit_not e ~bits =
    bit_xor e (const (ones_mask ~lower_inc:0 ~upper_inc:Int.(bits - 1)))

  let bit_at e ~bit = rshift e ~amt:(cint Int.(bit - 1)) |> bit_and one

  let bit_slice e ~lower_inc ~upper_inc =
    assert (Int.(lower_inc <= upper_inc));
    bit_and e (const (ones_mask ~lower_inc ~upper_inc))

  let pow _ _ = failwith "TODO"
  let of_bool v = Cbool.E.to_int v
  let lt a b = Expr.CInt.lt a b
  let gt a b = Expr.CInt.gt a b
  let le a b = Expr.CInt.le a b
  let ge a b = Expr.CInt.ge a b
  let is_zero e = eq e zero
  let is_nonzero e = ne e zero

  let assert_fits e ~bits =
    let assert_e = lt e (lshift one ~amt:(cint bits)) in
    Expr.with_assert_log ~new_max_bits:bits ~assert_e ~val_e:e ~log_e:e
      (fun c ->
        [%string
          "expected %{c#Cint0} < %{(Cint0.(pow (of_int 2) (of_int \
           bits)))#Cint0}"])

  let concat2 _ _ = failwith "TODO"
  let concat _ = failwith "TODO"
end

let apply_overflow dtype expr ~overflow =
  match overflow with
  | Overflow_behavior.Cant -> expr
  | Mask ->
      let bits = match Dtype.Ir.layout dtype with Bits_fixed width -> width in
      let mask = Cint0.(pow (of_int 2) (of_int bits) - of_int 1) in
      E.(bit_and expr (const mask))

module N = struct
  type t = Node.Wrap.t

  let assign ?loc var expr ~overflow =
    let var = Var.Ir.unwrap var in
    let expr = apply_overflow var.u.d.dtype expr ~overflow |> Expr.Ir.unwrap in
    Node.Ir.No_width_checks.assign ?loc var expr

  let incr ?loc var_id ~overflow =
    let expr = E.(var var_id |> add (cint 1)) in
    assign ?loc var_id expr ~overflow

  let decr ?loc var_id ~underflow =
    let expr = E.(sub (var var_id) (cint 1)) in
    assign ?loc var_id expr ~overflow:underflow

  let send ?loc chan_id expr ~overflow =
    let chan_id = Chan.Ir.unwrap_w chan_id in
    let expr =
      apply_overflow chan_id.d.dtype expr ~overflow |> Expr.Ir.unwrap
    in
    Node.Ir.No_width_checks.send ?loc chan_id expr

  let send' ?loc chan_id var_id ~overflow =
    send ?loc chan_id Expr.Wrap.(var var_id) ~overflow
end
