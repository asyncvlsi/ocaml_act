open! Core
include Cint0

let dtype ~bits =
  Dtype.Wrap.create ~equal ~sexp_of_t
    ~max_layout_of:(fun v -> Bits_fixed (bitwidth v))
    ~layout:(Bits_fixed bits)

let dtype_8 = dtype ~bits:8
let dtype_16 = dtype ~bits:16
let dtype_32 = dtype ~bits:32
let dtype_64 = dtype ~bits:64

(* basically all of the rest of this should be able to be autogenerated *)

module E = struct
  type t = Cint0.t Expr.Wrap.t

  include Expr.CInt_

  let zero = cint 0
end

let apply_overflow dtype expr ~overflow =
  match overflow with
  | Overflow_behavior.Cant -> expr
  | Mask ->
      let bits = match Dtype.Ir.layout dtype with Bits_fixed width -> width in
      let mask = Cint0.(pow (of_int 2) (of_int bits) - of_int 1) in
      E.(bit_and expr (const mask))

module N = struct
  type t = Node.Wrap.t

  let assign ?loc var expr ~overflow =
    let var = Var.Ir.unwrap var in
    let expr = apply_overflow var.u.d.dtype expr ~overflow |> Expr.Ir.unwrap in
    Node.Ir.No_width_checks.assign ?loc var expr

  let incr ?loc var_id ~overflow =
    let expr = E.(var var_id |> add (cint 1)) in
    assign ?loc var_id expr ~overflow

  let decr ?loc var_id ~underflow =
    let expr = E.(sub (var var_id) (cint 1)) in
    assign ?loc var_id expr ~overflow:underflow

  let send ?loc chan_id expr ~overflow =
    let chan_id = Chan.Ir.unwrap_w chan_id in
    let expr =
      apply_overflow chan_id.d.dtype expr ~overflow |> Expr.Ir.unwrap
    in
    Node.Ir.No_width_checks.send ?loc chan_id expr

  let send' ?loc chan_id var_id ~overflow =
    send ?loc chan_id Expr.Wrap.(var var_id) ~overflow
end
