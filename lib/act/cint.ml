open! Core
include Cint0

let dtype ~bits = Ir_dtype.cint_dtype ~bits |> Dtype.Internal.wrap
let dtype_4 = dtype ~bits:4
let dtype_8 = dtype ~bits:8
let dtype_16 = dtype ~bits:16
let dtype_32 = dtype ~bits:32
let dtype_64 = dtype ~bits:64

(* basically all of the rest of this should be able to be autogenerated *)

let mask bits = sub (pow two (of_int bits)) one

let ones_mask ~lower_inc ~upper_inc =
  assert (Int.(lower_inc <= upper_inc));
  let num_bits = Int.(upper_inc - lower_inc + 1) in
  mask num_bits |> left_shift ~amt:(of_int lower_inc)

module E = struct
  type t = Cint0.t Expr.t

  let var = Expr.var
  let of_cint = Expr.of_cint
  let of_int = Expr.of_int

  (* constants *)
  let zero = of_int 0
  let one = of_int 1
  let two = of_int 2
  let three = of_int 3
  let four = of_int 4
  let five = of_int 5

  (* ops *)
  let add a b = Expr.add a b
  let sub a b = Expr.sub a b
  let sub_wrap a b ~bits = Expr.sub_wrap a b ~bits
  let mul a b = Expr.mul a b
  let div a b = Expr.div a b
  let mod_ a b = Expr.mod_ a b
  let left_shift a ~amt = Expr.left_shift a ~amt
  let right_shift a ~amt = Expr.right_shift a ~amt
  let bit_and a b = Expr.bit_and a b
  let bit_or a b = Expr.bit_or a b
  let bit_xor a b = Expr.bit_xor a b
  let eq a b = Expr.eq a b
  let ne a b = Expr.ne a b
  let clip e ~bits = Expr.clip e ~bits
  let add_wrap a b ~bits = add a b |> clip ~bits
  let mul_wrap a b ~bits = mul a b |> clip ~bits

  let bit_not e ~bits =
    let mask = ones_mask ~lower_inc:0 ~upper_inc:(bits - 1) in
    bit_xor e (of_cint mask)

  let bit_at e ~bit = right_shift e ~amt:(of_int (bit - 1)) |> bit_and one

  let bit_slice e ~lower_inc ~upper_inc =
    assert (Int.(lower_inc <= upper_inc));
    bit_and e (of_cint (ones_mask ~lower_inc ~upper_inc))
    |> right_shift ~amt:(of_int lower_inc)

  let pow _ _ = failwith "TODO"
  let of_bool = Expr.int_of_bool
  let lt = Expr.lt
  let gt = Expr.gt
  let le = Expr.le
  let ge = Expr.ge
  let is_zero e = eq e zero
  let is_nonzero e = ne e zero

  let assert_fits e ~bits =
    let assert_e = lt e (left_shift one ~amt:(of_int bits)) in
    Expr.with_assert_log ~new_max_bits:bits ~assert_e ~val_e:e ~log_e:e
      (fun c ->
        [%string
          "expected %{c#Cint0} < %{(Cint0.(pow (of_int 2) (of_int \
           bits)))#Cint0}"])

  let concat2 _ _ = failwith "TODO"
  let concat _ = failwith "TODO"
end

let apply_overflow dtype expr ~overflow =
  match overflow with
  | Overflow_behavior.Cant -> expr
  | Mask ->
      let bits = match Ir_dtype.layout dtype with Bits_fixed width -> width in
      let mask = sub (pow two (of_int bits)) one in
      E.(bit_and expr (of_cint mask))

module Chp = struct
  type t = Chp.t

  let assign var expr ~overflow =
    let loc = Code_pos.psite () in
    let var = Var.Internal.unwrap var in
    let expr =
      apply_overflow var.d.dtype expr ~overflow |> Expr.Internal.unwrap
    in
    Ir_chp.Assign (loc, var, Ir_expr.untype expr) |> Chp.Internal.wrap

  let incr var_id ~overflow =
    let expr = E.(var var_id |> add one) in
    assign var_id expr ~overflow

  let decr var_id ~underflow =
    let expr = E.(sub (var var_id) one) in
    assign var_id expr ~overflow:underflow

  let send chan_id expr ~overflow =
    let loc = Code_pos.psite () in
    let chan_id = Chan.Internal.unwrap_w chan_id in
    let expr =
      apply_overflow chan_id.d.dtype expr ~overflow |> Expr.Internal.unwrap
    in
    Ir_chp.Send (loc, chan_id, Ir_expr.untype expr) |> Chp.Internal.wrap

  let send_var chan_id var_id ~overflow =
    send chan_id Expr.(var var_id) ~overflow
end

module Chan = struct
  let bw_le chan bw =
    let chan = Chan.Internal.unwrap_r chan in
    let chan_bw =
      match Ir_dtype.layout chan.d.dtype with Bits_fixed bits -> bits
    in
    Int.(chan_bw <= bw)

  let bw_ge chan bw =
    let chan = Chan.Internal.unwrap_w chan in
    let chan_bw =
      match Ir_dtype.layout chan.d.dtype with Bits_fixed bits -> bits
    in
    Int.(chan_bw >= bw)
end
