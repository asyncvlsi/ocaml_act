open! Core

module Ports_pack = struct
  type t = Act_extn.Act_id.t list [@@deriving sexp]
end

module Id : sig
  include Identifiable

  val new_id : unit -> t
end = struct
  include Int

  let next_id_val = ref 0

  let new_id () =
    let id = !next_id_val in
    incr next_id_val;
    id
end

module Chp_node = struct
  module Expr = struct
    (* This module is similar to Act_extn.Expr, but it is indexed by Id.t's, and
       supports renaming. It also could be made to generate better simulation
       functions for synthasizable circuits *)
    type 'o t = {
      eval : eval_var:(Act_extn.Act_id.Id.t -> Any.t) -> 'o;
      id_of_raw_id : Id.t Act_extn.Act_id.Id.Map.t;
    }
    [@@deriving sexp]

    let of_expr (expr : 'a Act_extn.Expr.t) ~of_id =
      {
        eval = expr.eval;
        id_of_raw_id =
          Set.to_list expr.ids
          |> List.map ~f:(fun id ->
                 let raw_id =
                   match id with
                   | Act_extn.Act_id.Var id -> id
                   | Chan { dir = _; partner = _; id } -> id
                   | _ -> failwith ""
                 in
                 let new_id = of_id id in
                 (raw_id, new_id))
          |> Act_extn.Act_id.Id.Map.of_alist_exn;
      }
  end

  module Stmt = struct
    type t =
      | Seq of t list
      | Par of t list
      | Loop of t list
      | DoWhile of (t list * CBool.t Expr.t)
      (* This should be 'a ChpChan.readable * 'a Var.t *)
      | Read of (Id.t * Id.t)
      (* This should be 'a ChpChan.writable * 'a Expr.t *)
      | Send of (Id.t * Any.t Expr.t)
      (* This should be 'a Var.t * 'a Expr.t *)
      | Assign of (Id.t * Any.t Expr.t)
      | Select of (CBool.t Expr.t * t list) list
      | Assert of CBool.t Expr.t
      | Log of string Expr.t
    [@@deriving sexp]
  end

  (* TODO varify each external chan corresponds to a unique Chp_chan *)

  type t = {
    stmt : Stmt.t;
    (* The order of this list matters *)
    ports : [ `R of Id.t | `W of Id.t ] list;
    internal_chans : (Id.t * Id.t) list;
    vars : Id.Set.t;
  }
  [@@deriving sexp]

  let of_chp stmt ~ports ~pack =
    let f stmt =
      let new_id_of_old_id = Act_extn.Act_id.Table.create () in
      let of_id act_id =
        Hashtbl.find_or_add new_id_of_old_id act_id ~default:(fun () ->
            Id.new_id ())
      in
      let of_expr expr = Expr.of_expr expr ~of_id in
      let rec f stmt =
        let of_stmts stmts = List.map stmts ~f in
        match stmt with
        | Act_extn.Chp_stmt.Seq stmts -> Stmt.Seq (of_stmts stmts)
        | Par stmts -> Par (of_stmts stmts)
        | Loop stmts -> Loop (of_stmts stmts)
        | DoWhile (stmts, expr) -> DoWhile (of_stmts stmts, of_expr expr)
        | Read (chan, var) -> Read (of_id chan, of_id var)
        | Send (chan, expr) -> Send (of_id chan, of_expr expr)
        | Assign (var, expr) -> Assign (of_id var, of_expr expr)
        | Select branches ->
            Select
              (List.map branches ~f:(fun (guard, stmts) ->
                   (of_expr guard, of_stmts stmts)))
        | Assert expr -> Assert (of_expr expr)
        | Log expr -> Log (of_expr expr)
      in
      let stmt = f stmt in
      (stmt, new_id_of_old_id |> Hashtbl.to_alist)
    in
    let stmt, new_id_of_old_id = f stmt in
    (* Now all the values sit inside the hashtbl *)
    let ids =
      List.map new_id_of_old_id ~f:(fun (old_id, new_id) ->
          match old_id with
          | Var _ -> `Var new_id
          | Chan _ ->
              failwith "unreachable - I dont collect this in the above code"
          | ChpChan (chan, _) -> (
              let { Act_extn.Act_id.Chan.dir; partner; id = chan_id } = chan in
              match (dir, partner) with
              | Readable, None -> `RPort (chan_id, new_id)
              | Writable, None -> `WPort (chan_id, new_id)
              | Readable, Some partner -> `RInternChan (chan_id, partner, new_id)
              | Writable, Some partner -> `WInternChan (chan_id, partner, new_id)
              ))
    in
    let vars =
      List.filter_map ids ~f:(function `Var new_id -> Some new_id | _ -> None)
      |> Id.Set.of_list
    in
    let rports =
      List.filter_map ids ~f:(function
        | `RPort (old_id, new_id) -> Some (new_id, old_id)
        | _ -> None)
      |> Id.Map.of_alist_exn
    in
    let wports =
      List.filter_map ids ~f:(function
        | `WPort (old_id, new_id) -> Some (new_id, old_id)
        | _ -> None)
      |> Id.Map.of_alist_exn
    in
    let internal_chans =
      let id_of_old_id =
        List.filter_map ids ~f:(function
          | `RInternChan (old_id, _, new_id) -> Some (old_id, new_id)
          | `WInternChan (old_id, _, new_id) -> Some (old_id, new_id)
          | _ -> None)
        |> Act_extn.Act_id.Id.Map.of_alist_exn
      in
      List.filter_map ids ~f:(function
        | `RInternChan (r, w, _) -> Some (r, w)
        | `WInternChan (w, r, _) -> Some (r, w)
        | _ -> None)
      |> List.map ~f:(fun (r, w) ->
             (Map.find_exn id_of_old_id r, Map.find_exn id_of_old_id w))
    in
    let id_of_act_id =
      [ Map.to_alist rports; Map.to_alist wports ]
      |> List.concat
      |> List.map ~f:(fun (new_, old) -> (old, new_))
      |> Act_extn.Act_id.Id.Map.of_alist_exn
    in
    let ports =
      pack ports
      |> List.map ~f:(fun port ->
             match port with
             | Act_extn.Act_id.Chan { dir; id; _ } -> (
                 let id = Map.find_exn id_of_act_id id in
                 match dir with Readable -> `R id | Writable -> `W id)
             | _ -> failwith "")
    in
    { stmt; vars; ports; internal_chans }
end

module Subnode_node = struct
  type inst
  type t = { subnodes : inst list; ports : [ `R of Id.t | `W of Id.t ] list }
end

module Inst = struct
  type t =
    | Chp of Chp_node.t * Act_extn.Act_id.t list
    | Nodes of t list * (Act_extn.Act_id.t * Act_extn.Act_id.t) list
    | Conn of (Act_extn.Act_id.t * Act_extn.Act_id.t)
  [@@deriving sexp]

  let inflate _ = failwith "unimplemented"
end

type 'a t =
  | Chp of (('a -> Ports_pack.t) * Chp_node.t)
  | Nodes of (('a -> Ports_pack.t) * Inst.t list * Ports_pack.t)
[@@deriving sexp]

let of_chp chp ~ports ~pack = Chp (pack, Chp_node.of_chp chp ~ports ~pack)
let of_nodes subnodes ~ports ~pack = Nodes (pack, subnodes, pack ports)

let inst t ports =
  match t with
  | Chp (pack, node) -> Inst.Chp (node, pack ports)
  | Nodes (pack, nodes, node_ports) ->
      Inst.Nodes (nodes, List.zip_exn node_ports (pack ports))

let conn_inst in_ out =
  Inst.Conn (Act_extn.Chan.R.id in_, Act_extn.Chan.W.id out)
