open! Core

module Act_id : sig
  module Id : sig
    include Identifiable

    val new_id : unit -> t
  end

  module Dir : sig
    type t = Readable | Writable
  end

  module Chan : sig
    type t = { dir : Dir.t; partner : Id.t option; id : Id.t }
  end

  type t = Var of Id.t | Chan of Chan.t | ChpChan of Chan.t * Id.t
  [@@deriving sexp]

  include Comparable with type t := t
  include Hashable with type t := t

  val new_var_id : unit -> t
  val new_chan_r_id : unit -> t
  val new_chan_w_id : unit -> t
  val new_chan_rw_ids : unit -> t * t
  val new_chp_chan_id : t -> unit -> t
end

module Var : sig
  type 'dk t

  val id : 'dk t -> Act_id.t
  val create : unit -> 'dk t

  module Value_map : sig
    type 'dk var = 'dk t
    type t

    val create : unit -> t
    val find : t -> 'a var -> 'a option
    val set : t -> 'a var -> 'a -> t

    (* sends (t, renaming) to {k: t[v] for (k,v) in renaming} *)
    (* val apply_renaming_inv : t -> Act_id.t Act_id.Map.t -> t *)
  end
end

module Chan : sig
  module Conn : sig
    type t = Act_id.t * Act_id.t [@@deriving sexp]
  end

  module R : sig
    type 'dk t [@@deriving sexp]

    val id : 'dk t -> Act_id.t
    val new_ : unit -> 'dk t
    val conn_port : 'dk t -> 'dk t -> Conn.t
  end

  module W : sig
    type 'dk t [@@deriving sexp]

    val id : 'dk t -> Act_id.t
    val new_ : unit -> 'dk t
    val conn_port : 'dk t -> 'dk t -> Conn.t
  end

  module P : sig
    type 'dk t = { r : 'dk R.t; w : 'dk W.t } [@@deriving sexp]

    val new_ : unit -> 'dk t
  end

  val conn_chain : 'dk R.t -> 'dk W.t -> Conn.t
end

module Chp_chan : sig
  module R : sig
    type 'dk t

    val of_chan : 'dk Chan.R.t -> unit -> 'dk t
    val id : 'dk t -> Act_id.t
  end

  module W : sig
    type 'dk t

    val of_chan : 'dk Chan.W.t -> unit -> 'dk t
    val id : 'dk t -> Act_id.t
  end
end

module Expr : sig
  type 'o t = {
    eval : eval_var:(Act_id.Id.t -> Any.t) -> 'o;
    ids : Act_id.Set.t;
  }
  [@@deriving sexp, fields]

  val of_var : 'dk Var.t -> 'dk t
  val of_cint : CInt.t -> CInt.t t
  val of_cbool : CBool.t -> CBool.t t
  val map : 'i t -> f:('i -> 'o) -> 'o t
  val mapv : 'i Var.t -> f:('i -> 'o) -> 'o t
  val map2 : 'i1 t -> 'i2 t -> f:('i1 -> 'i2 -> 'o) -> 'o t
end

module Chp_stmt : sig
  (* TODO somehow only expose this to the other modules in this directory *)
  type t =
    | Seq of t list
    | Par of t list
    | Loop of t list
    | DoWhile of (t list * CBool.t Expr.t)
    (* This should be 'a ChpChan.readable * 'a Var.t *)
    | Read of (Act_id.t * Act_id.t)
    (* This should be 'a ChpChan.writable * 'a Expr.t *)
    | Send of (Act_id.t * Any.t Expr.t)
    (* This should be 'a Var.t * 'a Expr.t *)
    | Assign of (Act_id.t * Any.t Expr.t)
    | Select of (CBool.t Expr.t * t list) list
    | Assert of CBool.t Expr.t
    | Log of string Expr.t
  [@@deriving sexp]

  module GuardedBranch : sig
    type nonrec t = CBool.t Expr.t * t list
  end

  val seq : t list -> t
  val par : t list -> t
  val assign : 'data Var.t -> 'data Expr.t -> t
  val read : 'data Chp_chan.R.t -> 'data Var.t -> t
  val send : 'data Chp_chan.W.t -> 'data Expr.t -> t
  val loop : t list -> t
  val do_while : t list -> guard:CBool.t Expr.t -> t
  val select : GuardedBranch.t list -> t
  val assert_ : CBool.t Expr.t -> t
  val log : string Expr.t -> t
  val branch : guard:CBool.t Expr.t -> t list -> GuardedBranch.t
end
