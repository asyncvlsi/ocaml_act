open! Core
module Expr = Ir.Expr

module STF_Var : sig
  type t = { id : int; bitwidth : int } [@@deriving sexp, hash, equal, compare]

  include Comparable.S with type t := t
  include Hashable.S with type t := t
end

module STF : sig
  module Par_split : sig
    type t = { in_v : STF_Var.t; out_vs : STF_Var.t option list }
    [@@deriving sexp]
  end

  module Par_merge : sig
    type t = { in_vs : STF_Var.t option list; out_v : STF_Var.t }
    [@@deriving sexp]
  end

  module DoWhile_phi : sig
    type t = {
      init_v : STF_Var.t option;
      body_in_v : STF_Var.t option;
      body_out_v : STF_Var.t option;
      out_v : STF_Var.t option;
    }
    [@@deriving sexp]
  end

  module Select_split : sig
    type t = { in_v : STF_Var.t; out_vs : STF_Var.t option list }
    [@@deriving sexp]
  end

  module Select_merge : sig
    type t = { in_vs : STF_Var.t list; out_v : STF_Var.t } [@@deriving sexp]
  end

  type t =
    | Nop
    | Assign of STF_Var.t * STF_Var.t Expr.t
    | Read of Ir.Chan.t * STF_Var.t
    | Send of Ir.Chan.t * STF_Var.t Expr.t
    | Seq of t list
    | Par of Par_split.t list * t list * Par_merge.t list
    | SelectImm of
        STF_Var.t Expr.t * Select_split.t list * t list * Select_merge.t list
    | DoWhile of DoWhile_phi.t list * t * STF_Var.t Expr.t
  [@@deriving sexp]
end

val stf_of_dflow_interface_for_chp_proc :
  Ir.Dflow_interface_for_chp_proc.t -> STF.t

val optimize_stf : STF.t -> STF.t
