open! Core
open! Act

(* End of the "library" code *)
module Spliter = struct
  let block ~in_ =
    let open Chp in
    let mb = CInt.Chan.R.mb in_ in
    let out_1 = CInt.Chan.P.new_ ~mb () in
    let out_2 = CInt.Chan.P.new_ ~mb () in
    let b = CBool.Var.new_ () in
    let v = CInt.Var.new_ ~mb () in
    let chp =
      Stmt.loop
        [
          Stmt.read in_ v;
          Stmt.select_bool b ~f:(function
            | true -> [ Stmt.send out_1.w (Expr.of_var v) ]
            | false -> [ Stmt.send out_2.w (Expr.of_var v) ]);
          Stmt.flip b;
        ]
    in
    let chp = Block.of_chp_exn chp ~ports:[ in_.ut; out_1.w.ut; out_2.w.ut ] in
    ((out_1.r, out_2.r), chp)

  let%expect_test "chp block" =
    let _, block = block ~in_:(CInt.Chan.R.new_ ~mb:(Bits.of_int 3) ()) in
    Chp.Block.print block;
    [%expect {||}]

  let inst ~in_ =
    let outs, block = block ~in_ in
    (outs, Node_inst.of_chp block)

  let sim ~mb =
    let in_ = CInt.Chan.P.new_ ~mb () in
    let (out_1, out_2), node = inst ~in_:in_.r in
    ((in_.w, out_1, out_2), Sim.sim node)

  let%expect_test "test0" =
    let (in_, out_1, out_2), sim = sim ~mb:(Bits.of_int 4) in
    Sim.d_test sim
      ~inputs:
        [ Sim.D.new_w in_ (CInt.l_of_l [ 1; 2; 3; 4; 5; 6; 7; 8; 9; 10 ]) ]
      ~expected:
        [
          Sim.D.new_r out_1 (CInt.l_of_l [ 1; 3; 5; 7; 9 ]);
          Sim.D.new_r out_2 (CInt.l_of_l [ 2; 4; 6; 8; 10 ]);
        ];
    [%expect {||}]

  let%expect_test "test0" =
    let (in_, out_1, out_2), sim = sim ~mb:(Bits.of_int 1) in
    Sim.d_test sim
      ~inputs:[ Sim.D.new_w in_ (CInt.l_of_l [ 1; 0; 1; 0; 1 ]) ]
      ~expected:
        [
          Sim.D.new_r out_1 (CInt.l_of_l [ 1; 1; 1 ]);
          Sim.D.new_r out_2 (CInt.l_of_l [ 0; 0 ]);
        ];
    [%expect {||}]

  let%expect_test "test1" =
    (* The circuit passes the value on as expected. We dont specify the order
       between the read and the write. The order between subsequent actions on
       the same channel is preserved, but there is no guarentee between
       different channels *)
    let (in_, out_1, out_2), sim = sim ~mb:(Bits.of_int 1) in
    Sim.read sim out_2 (CInt.of_int 321);
    Sim.read sim out_1 (CInt.of_int 123);
    Sim.send sim in_ (CInt.of_int 123);
    Sim.send sim in_ (CInt.of_int 321);
    Sim.wait sim;
    [%expect {||}]

  let%expect_test "test2" =
    (* checks that we can send strictly before we can read *)
    let (in_, out_1, out_2), sim = sim ~mb:(Bits.of_int 1) in
    Sim.send_and_wait sim in_ (CInt.of_int 123);
    Sim.read_and_wait sim out_1 (CInt.of_int 123);
    Sim.send_and_wait sim in_ (CInt.of_int 321);
    Sim.read_and_wait sim out_2 (CInt.of_int 321);
    [%expect {||}]

  let%expect_test "test3" =
    (* checks that we cannot read before we send *)
    let (in_, out_1, _), sim = sim ~mb:(Bits.of_int 1) in
    Sim.read_and_wait sim out_1 (CInt.of_int 123);
    Sim.send_and_wait sim in_ (CInt.of_int 123);
    [%expect {||}]

  let%expect_test "test4" =
    (* checks that we cannot send twice before reading *)
    let (in_, _, _), sim = sim ~mb:(Bits.of_int 1) in
    Sim.send_and_wait sim in_ (CInt.of_int 123);
    Sim.send_and_wait sim in_ (CInt.of_int 123);
    [%expect {||}]
end

module Merger = struct
  let inst ~in_1 ~in_2 =
    let open Chp in
    assert (Bits.equal (CInt.Chan.R.mb in_1) (CInt.Chan.R.mb in_2));
    let mb = Bits.max (CInt.Chan.R.mb in_1) (CInt.Chan.R.mb in_2) in
    let out = CInt.Chan.P.new_ ~mb () in
    let b = CBool.Var.new_ () in
    let v = CInt.Var.new_ ~mb () in
    let chp =
      Stmt.loop
        [
          Stmt.select_bool b ~f:(function
            | true -> [ Stmt.read in_1 v ]
            | false -> [ Stmt.read in_2 v ]);
          Stmt.flip b;
          Stmt.send out.w (Expr.of_var v);
        ]
    in
    let chp = Block.of_chp_exn chp ~ports:[ in_1.ut; in_2.ut; out.w.ut ] in
    (out.r, Node_inst.of_chp chp)
end

module Buffer = struct
  let rec inst ~depth ~in_ =
    if depth <= 0 then failwith "depth <= 0";
    let subinst ~in_ =
      match depth with
      | 1 -> (in_, Node_inst.null_inst)
      | _ -> inst ~depth:(depth - 1) ~in_
    in
    let (split_out_1, split_out_2), split = Spliter.inst ~in_ in
    let buff1_out, buff1 = subinst ~in_:split_out_1 in
    let buff2_out, buff2 = subinst ~in_:split_out_2 in
    let out, merge = Merger.inst ~in_1:buff1_out ~in_2:buff2_out in
    (out, Node_inst.of_subnodes [ split; buff1; buff2; merge ])
end

(*
   module ALU = struct
     module Cmds : sig
       val bits : int

       module Op : sig
         type t =
           | Fn2 of (int Var.t -> int Var.t -> int Expr.t)
           | Fn1 of (int Var.t -> int Expr.t)
       end

       type t = Add | Mul | LShift | Bitwise_not

       val op : t -> Op.t
       val all : t list
       val guard_expr : t -> int Var.t -> bool Expr.t
     end = struct
       let bits = 2

       module Op = struct
         type t =
           | Fn2 of (CInt.t Var.t -> CInt.t Var.t -> CInt.t Expr.t)
           | Fn1 of (CInt.t Var.t -> CInt.t Expr.t)
       end

       type t = Add | Mul | LShift | Bitwise_not [@@deriving equal]

       let all = [ Add; Mul; LShift; Bitwise_not ]

       let int_val t =
         List.findi all ~f:(fun _ e -> equal e t) |> Option.value_exn |> fst

       let guard_expr t v =
         let nbits = bits in
         Expr.(eq (of_const (int_val t) ~bits:nbits) (of_var v))

       let op t =
         let op1 f = Op.Fn1 (fun v1 -> Expr.(f (of_var v1))) in
         let op2 f = Op.Fn2 (fun v1 v2 -> Expr.(f (of_var v1) (of_var v2))) in
         match t with
         | Add -> op2 Expr.add
         | Mul -> op2 Expr.mult
         | LShift -> op2 Expr.lshift
         | Bitwise_not -> op1 Expr.not
     end

     module Ports = struct
       type 'data t = {
         cmd : int Chan.readable;
         arg_1 : int Chan.readable;
         arg_2 : int Chan.readable;
         out : int Chan.writable;
       }

       let create () =
         let cmd = Chan.new_r ~kind:(Int 2) () in
         let arg_1 = Chan.new_r ~kind:(Int 16) () in
         let arg_2 = Chan.new_r ~kind:(Int 16) () in
         let out = Chan.new_w ~kind:(Int 16) () in
         { cmd; arg_1; arg_2; out }

       (* The functions `zip` and `to_chp` and the module `Chp` could be auto-generated *)

       let zip t1 t2 =
         [
           Chan.Conn.port t1.cmd t2.cmd;
           Chan.Conn.port t1.arg_1 t2.arg_1;
           Chan.Conn.port t1.arg_2 t2.arg_2;
           Chan.Conn.port t1.out t2.out;
         ]

       module Chp = struct
         type 'data t = {
           cmd : int Chp_chan.readable;
           arg_1 : int Chp_chan.readable;
           arg_2 : int Chp_chan.readable;
           out : int Chp_chan.writable;
         }
       end

       let to_chp { cmd; arg_1; arg_2; out } =
         let cmd = Chp_chan.new_r cmd () in
         let arg_1 = Chp_chan.new_r arg_1 () in
         let arg_2 = Chp_chan.new_r arg_2 () in
         let out = Chp_chan.new_w out () in
         { Chp.cmd; arg_1; arg_2; out }
     end

     let node =
       let ports = Ports.create () in
       let chp =
         let { Ports.Chp.cmd; arg_1; arg_2; out } = Ports.to_chp ports in
         let c = Var.create ~kind:(Int 2) () in
         let v1 = Var.create ~kind:(Int 16) () in
         let v2 = Var.create ~kind:(Int 16) () in
         let v3 = Var.create ~kind:(Int 16) () in
         Chp_stmt.loop
           [
             Chp_stmt.read cmd c;
             Chp_stmt.select
               (List.map Cmds.all ~f:(fun cmd_ ->
                    branch ~guard:(Cmds.guard_expr cmd_ c)
                      [
                        Chp_stmt.par
                          (match Cmds.op cmd_ with
                          | Fn1 _ -> [ Chp_stmt.read arg_1 v1 ]
                          | Fn2 _ -> [ Chp_stmt.read arg_1 v1; Stmt.read arg_2 v2 ]);
                        (match Cmds.op cmd_ with
                        | Fn1 op -> Chp_stmt.assign v3 (op v1)
                        | Fn2 op -> Chp_stmt.assign v3 (op v1 v2));
                        Chp_stmt.send out v3;
                      ]));
           ]
       in
       Node.of_chp chp ~ports

     let inst ports = Node.inst node ports ~zip:Ports.zip
   end

   let%expect_test "addition" =
     printf "%d" (1 + 7);
     [%expect {| 8 |}]
 *)
